= 30分でわかるJavaScriptプログラマのためのモナド入門
Ken Okabe <kentutorialbook@gmail.com>
:keywords:  monad, JavaScript, ECMAScript, Promise, FRP, timeline
:description: timeline FRP Monad
:homepage:    https://kenokabe.github.io/timeline-monad/
:source:      https://github.com/kenokabe/timeline-monad
:toc:
:sectnums:
:toclevels: 2
:source-highlighter: highlightjs
:highlightjs-theme: solarized-dark
:imagesdir: ./img/ 
:stem: latexmath
 

:leveloffset: 1

= モナドが難しい？

巷の解説が混乱に満ちあふれている・・・

== モナドを理解するのが難しい理由

-**数学と用語問題。**モナドの理論的基盤として圏論があるのは事実。理論的基盤がしっかりしているのはプログラミングという数学的作業において歓迎すべきことではある一方で、他方そのため一般的なプログラマにとってはまず用語に馴染みがない。歴史的に、圏論ベースのモナドを理論から関数型プログラミングに応用されていく過程では、実際、先駆者の間でさえ紆余曲折があったのだが、学習者へは馴染みのない用語を伴って、いきなり数学的概念全開で天下り的に提示されてしまうことが多い。わかっている人、そもそも実用性以上に数学性、理論的側面に興味がある人にとっては知的好奇心を掻き立てられるトピックではあるが、そうでないプログラマにとっては「難しい、とっつきにくい、学習コストが大きすぎて実用性もよくわからない」となることが多い。「わからないの？ならとりあえず、巷の半端な解説より
http://homepages.inf.ed.ac.uk/wadler/topics/monads.html[Philip Wadler先生の数々の素晴らしい論文]を読んだほうがいい！」という人もいるが、ほとんどの学習者にとって、そういうアドバイスをされる時点で、このアプローチは絶望的である。

-**Haskellに寄りすぎ問題。**歴史的に、圏論のモナドが関数型プログラミングへ応用できることが発見され、論文が発表された際に、使用された言語はHaskellであり、関数型言語としてのHaskellの根源的なフレームワークとして積極的にモナドが導入された。そのためHaskellerにとってはモナドの理解は必須要項であり、情報交換もHaskellのSyntaxをもって活発に行われている。彼らの知識の源泉は主にlink:https://wiki.haskell.org/Monad[Monad - Haskell Wiki]であったり、link:https://ja.wikibooks.org/wiki/Haskell/%E5%9C%8F%E8%AB%96#%E3%83%A2%E3%83%8A%E3%83%89[Haskell/圏論#モナド]であったり、link:http://learnyouahaskell.com/chapters[Learn You a Haskell for Great Good!](無料配布)（有料日本語訳『すごいHaskellたのしく学ぼう!』）であったりして、ほとんどの場合そのHaskellで一般的な用語、Syntaxで語られる。Haskellerにとっては「モナドとはすでに手元にあるもの」であり、手元あるいは、足場となる言語を活用するための学習モティベーションも極めて高い。裏を返すと、Haskellerでないその他大勢のプログラマにとっては以上の事実は逆風となる。

-**複数の新規概念ごっちゃまぜ問題。**モナドが関数型プログラミングに応用される際、学習者にとっては。複数にわたる本来興味深いはずの新規概念があるのだが、それらはほとんどの場合整理されて説明されることはない。たとえば上記のHaskellに寄りすぎ問題により、Haskellの基本的文法とからめて天下り的に `do` とか `IO` だ、などとしょっぱなから当たり前のように言われるのだが、これはモナドを非同期プログラミング、FRPの概念と合わせて**応用する話**であり、モナドの概念導入段階では本来すべき話ではない。事実モナドの関数型プログラミングへの応用黎明期では、モナドによって入出力（IO）が扱える、とPhilip Wadler先生たちから提案されたのはちょっと後になってからだ。聡明な専門家の間でさえそんな感じだったのだから、IO、それから状態管理への展開はこれはこれでひとつの一大発明であって、モナドの応用シーンとして、面白い別トピックとしてわけて考えたほうがいい。これはFRPの先駆者であるConal ElliottもStackOverflowのlink:https://stackoverflow.com/questions/16439025/what-is-so-special-about-monads[モナドの何がそんなに特別なのか？]へのlink:https://stackoverflow.com/a/16444789[回答として、似たようなことを主張している]。

> (Haskellの)Monadタイプクラスへの不釣り合いなまでの大注目度合いは歴史的な幸運にすぎない。彼らはよくIOをモナドを関連づけるが、この２つは独立した有用な概念だ。(関数型プログラミングでの）IOはマジカルで、モナドはそのIOとしょっちゅう関連づけられているので、モナドがマジカルだという錯覚に陥りやすい。


= JavaScriptプログラマのためのモナド入門

== 対象とする読者

関数型プログラミングをしたいJavaScriptプログラマーでモナドを理解したい人。

関数型プログラミングについて入門したい人は、当ブログの入門記事から。


[TIP]
====
https://kentechdoc.blogspot.com/2018/06/day-jsvar-s-0for-var-n-1-n-b-const-s2-1.html[関数型プログラミング超入門]
====



とりあえず配列とMapがわかればいいです。

== 本稿のアプローチ

<<_モナドを理解するのが難しい理由>>をアンチパターンとして最大限留意しています。


= なぜモナドか

JavaScript上で実用的だから。

上述のとおり、モナドとは関数型プログラミングの一部です。

関数型プログラミングは、プログラミングの複雑性を、以下の２つ

- 値
- 値でもある関数

の組み合わせ（function composition）で制御します。（この２つの組み合わせについては後で追加説明します。）

== jQuery

いろんな値＆関数が考えられるわけですが、JavaScript世界で超有名なのが、 https://jquery.com/[jQuery]でしょう。jQueryのオフィシャルロゴには _"write less, do more"_ とあり、それまで不十分なAPIにより煩雑だったDOM操作を簡潔な記法で柔軟に操作できる値＆関数を提供し、その実用性の高さから人気を集めました。

_"write less, do more"_　とは、複雑なプログラムをなるだけシンプルに取り扱おうとする関数型プログラミングの唯一にして究極のゴールの具現化そのものであり、一例をあげてみると、


[source,js]
.tryjquery_chaining2
----
$("#p1")
    .css("color", "red")
    .slideUp(2000)
    .slideDown(2000);
----

と、link:https://www.w3schools.com/jquery/jquery_chaining.asp[メソッドチェーンをもって書き連ねる]だけで、link:https://www.w3schools.com/jquery/tryit.asp?filename=tryjquery_chaining2[Demo:こんなこと]ができるようになるとか、衝撃的ですらあります。要するに、この _"write less, do more"_ こそが、関数型プログラミングの真価であり、jQueryはただひとつの、 `$()` というjQueryオブジェクト生成関数と、それにぶら下がる巨大なメソッド群から成立していて使い方はシンプルです。

jQueryは値(オブジェクト)＆関数（オブジェクトにぶらさがるメソッド群）のペアです。

jQueryがモナドかどうか？というのはしばしば議論にあがるところですが、jQueryのAPIは巨大なので、その全部がモナドであるわけではないが、そのうちの一部はモナドになっている、というのが答えでしょう。そしてここで重要なのは白黒つけることではなくて、要するにJavaScript世界で広く便利に活用されるモナドの一例として、こういう便利なjQueryがあげられる、ということです。

全部がモナドではないが一部は確実にモナドである、という別の事例として、Arrayの新規メソッドがあげられます。これについては次の章で。

== Promise

ES6+ 以降で導入された https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Using_promises[Promise]も一部モナドっぽいふるまいをします。厳密にはモナドではありません。PromiseはjQueryほど巨大なAPIではないので、すべて厳密にモナドであったほうが有用性はあがるはずですが、そうではないので残念です。

Promiseはすでに、ESModule

[NOTE]
====
http://kenokabetech.blogspot.com/2018/09/20189javascriptes-moduleesm.html[2018年9月時点のJavaScriptモジュール(ES Module/ESM)界隈の最新情報、これまでの経緯とこれからの見通しを解説]

https://kentechdoc.blogspot.com/2018/09/es-modulesesm-jdalton.html[明日のES Modulesを今日使おう！(esm ライブラリ開発者 @jdalton による解説記事の翻訳)]
====

の動的Importの返り値として標準化されるなど、今どきのJavaScriptプログラマにとっては必須事項となってしまいました。Promiseが「モナドっぽい」振る舞いをするが、そうでない振る舞いするときもある、と挙動を把握しておくこと、人に説明できるほど理解しておくことは、Promiseを正しく使いこなすためにも重要だと思います。


[[relation]]
= 代数学と関数型プログラミングとオブジェクト指向の用語・記法の相互関係

とりあえずさっさと「モナドとは何か？」の説明を具体例をもって進めたいところですが、曖昧になっている要素を排除し、きちんと説明の土壌を整備しておいたほうが良いので、急がば廻れの精神で先にやっておきます。

前段の<<_なぜモナドか>>で、

---
---
関数型プログラミングは、プログラミングの複雑性を、以下の２つ

- 値
- 値でもある関数

の組み合わせ（function composition）で制御します。

---

メソッドチェーンをもって書き連ねるだけで、Demo:こんなことができるようになる

---

jQueryは値(オブジェクト)＆関数（オブジェクトにぶらさがるメソッド群）のペアです。

---
---


などと書き連ねたわけですが、これは問題があります。

多数の意味が曖昧な言葉、定義がはっきりしない、その正体についてはJavaScriptや関数型プログラミングとオブジェクト指向プログラミングで出て来がちな複数の文脈で暗黙の了解に委ねられている用語が散見されます。

- 値
- 関数
- オブジェクト
- メソッド

オブジェクト・メソッドについては明らかに出自がオブジェクト指向の用語です。

値、関数については、関数型ぽいが、同時にオブジェクト指向でも使われたりする。

JavaScriptは良かれ悪しかれ「マルチパラダイムプログラミング」言語なので、こういうわけのわからない状況に至ってもまあ仕方はないですが、特に関数型プログラミングを導入する際に曖昧さと混乱を引きずったままでゴリ押ししてしまうことが多いです。

用語は違うのに、数学的対象としては同じものを指し示していたりすることで、概念の重複、冗長性、曖昧さが生じてしまっています。

== 小学１/２年の算数からの復習

そこでとりあえず、根底となるプロトコルである数学の記法についてまず整理しておきましょう。

数学と言ってもたいしたことはない、小学１/２年の算数レベルのお話です。


[stem]
++++
1 + 2 = 3
++++

[stem]
++++
1 \times 2 = 2
++++

これは初等数学で真っ先に習う
https://ja.wikipedia.org/wiki/%E7%AE%97%E8%A1%93#%E5%9B%9B%E5%89%87%E6%BC%94%E7%AE%97[四則演算]のうち「加算」と「乗算」です。

またさらに一般化、抽象化して、「2つの数から新たな数を決定する演算」のことを https://ja.wikipedia.org/wiki/%E4%BA%8C%E9%A0%85%E6%BC%94%E7%AE%97[二項演算]と呼びます。要するに**演算のパラメータが２つあったらそれは二項演算**。また、２つのパラメータの中間に `+` 、`-` などの演算子を置くのを https://ja.wikipedia.org/wiki/%E4%B8%AD%E7%BD%AE%E8%A8%98%E6%B3%95[中置記法]と呼びます。

パラメータが１個ならば、 https://ja.wikipedia.org/wiki/%E5%8D%98%E9%A0%85%E6%BC%94%E7%AE%97[単項演算] で、中学で習う平方根の演算子、ルートを使って 

[stem]
++++
\sqrt9 = 3
++++

となりますね。

== 演算は関数として捉えられる

パラメータの文字が出た時点でお察しですが、以上の演算は関数として解釈できます。

単項演算は、パラメータが１個なので、

[source,js]
.Math.sqrt
----
Math.sqrt(9) //3
----

二項演算は、パラメータが2個なので、

[source,js]
.plus
----
const plus = (a) => (b) => (a + b);

plus(1)(2) //3
----

== オブジェクト指向のメソッドでは

ここであえて復習するつもりもありませんが、オブジェクト指向のメソッドとは、オブジェクトに紐付いた関数のことですね。

JavaScriptの数値はカッコ（）で囲んでやると、 https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Number[Numberオブジェクト]になるので、`Number.prototype` へ新たに `plus` メソッドを追加します。


[[NumberPlus]]
[source,js]
.Number(a).plus(b)
----
Object.defineProperty(
    Number.prototype,
    "plus", {
        value: function (b) {
            return this + b;
        }
    });
----


[source,js]
.(1).plus(2) === 3
----
(1).plus(2) //3
----

- オブジェクト自身の値 `this = 1` 
- メソッド `plus` 関数
- パラメータ `2`

二項演算（中置記法）

[stem]
++++
1 + 2
++++

は、JavaScriptのオブジェクトとメソッドで書けます。

[stem]
++++
(1).plus(2) 
++++

そして、このように、値(オブジェクト)＆関数（オブジェクトにぶらさがるメソッド）のペアで書くのは非常に優れているんですね。

jQueryのメソッドチェーンのことを思い出しましょう。


[stem]
++++
1 + 2 + 5 + 9
++++

は、そのまま、

[stem]
++++
(1).plus(2).plus(5).plus(9) 
++++

と、メソッドチェーンで自然に書けてしまう。

オブジェクトにぶらさがるメソッドではない普通の関数の形式

[stem]　
++++
plus(1)(2)
++++
ではこううまくは行きません。

[stem]　
++++
plus(plus(plus(1)(2))(5))(9)
++++

「なんとか地獄」と名前がつきそうな感じです。

JavaScriptがマルチパラダイムで、オブジェクト指向のメソッド形式で書けるおかげで、**任意の二項演算、つまりパラメータを２つとる関数は、特別な定義不要で、その関数名（メソッド名）のまま中置記法が実現できてしまう**という予期しない副産物（棚ぼた）です。

== 値と演算は常に組（ペア）で存在する

> 抽象代数学におけるマグマ（英語: magma）または亜群（あぐん、groupoid）は、演算によって定義される種類の基本的な代数的構造であり、**集合 M とその上の二項演算 M × M → M からなる組をいう**。マグマ M における二項演算は M において閉じていることは要求するが、それ以外の何らの公理も課すものではない。
https://ja.wikipedia.org/wiki/%E3%83%9E%E3%82%B0%E3%83%9E_(%E6%95%B0%E5%AD%A6)[マグマ(数学)]

基本的な代数構造において、演算だけ独立して存在していることはありません。必ず演算のターゲットとなる値の集合と組（ペア）として存在しています。

たとえば、 四則演算のうち「加算」は演算対象となるデータとは加算可能な数値ですよね？文字列であったり、なにかの画像データではありません。

_抽象代数学_ とか _代数的構造_ とか言われると、つい数値のことを連想しがちなのですが、

> マグマ M における二項演算は M において閉じていることは要求するが、それ以外の何らの公理も課すものではない。

とあるとおり、なんの制約もありません。

値が文字列ならば、その組となる、文字列というデータを演算するための二項演算は自由に定義可能だし、実際JavaScriptには、 https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/String[String]プロトタイプオブジェクトと、それ専用の二項演算子が実装されています。


[source,js]
.Hello world
----
  "Hello" + " " + "world"  //Hello world
----

文字列データを二項演算するときの `+` は文字列の接続処理で、数値データを二項演算する `+` の加算処理とは意味が異なります。**値と演算は常に組（ペア）で存在するのであって、演算子の単独では意味を成しません**。

そしてこれは、まさに**オブジェクトとメソッドの関係に合致**しており、二項演算の連続的操作が、そのまま上手くオブジェクトのメソッドチェーンで書けてしまう理論的背景が納得できます。

関数型プログラミングで、値、関数というとき、暗黙に組（ペア）となる相手がいます(プログラムで処理されないデータは意味がない)。そして、静的型付けの仕組み（JavaScriptならTypeScriptを使えばいい）などで、この値と関数の組（ペア）性を保証していきます。

しかし、繰り返し、これはまったく想定外のことですが、関数型プログラミングであっても、オブジェクト指向のオブジェクトとメソッドという組は、値（データ）と演算（関数）が組となる二項演算を定義する代数構造と解釈することで極めて有用です。

== まとめ

二項演算をベースに考える。


[NOTE]
====

マグマ（英語: magma）または亜群（あぐん、groupoid）は、演算によって定義される種類の基本的な代数的構造であり、集合 M とその上の二項演算 M * M → M からなる組をいう。

値と演算は常に組（ペア）で存在するのであって、演算子の単独では意味を成しません。

---

と、逐一書くのも面倒なので、今後マグマという組（ペア）は

[stem]
++++
(M, ∗) 
++++



と書くことにします。

演算 `*` はワイルドカードです。二項演算 M ∗ M → M  ならなんでも良い。

たとえば、二項演算が**自然数の足し算**と定まれば、ワイルドカード `*` は `+` になります。

[stem]
++++
(自然数,+) 
++++


二項演算が**自然数の掛け算**と定まれば、

[stem]
++++
(自然数,\times) 
++++

繰り返し念の為ですが、代数構造といえども、対象となるデータは、数値に限りません。

二項演算が**文字列の接続**と定まれば、ワイルドカード `*` は `+` になります。

[stem]
++++
(文字列,+) 
++++


====

マグマ(M, ∗) はプログラムの世界にそのまま展開できて、

`M` = 値、データ、オブジェクト

`*` = 二項演算、パラメータ２つの関数、メソッド

と言うように、データと処理の組、つまり**データ処理**のことだと解釈できます。

[stem]
++++
1 + 2 + 5 + 9
++++

という二項演算の連続的操作は、そのまま、

[stem]
++++
(1).plus(2).plus(5).plus(9) 
++++

とオブジェクトのメソッドチェーンとして表現できる。


.代数、関数型、オブジェクト指向のイディオム
[cols="h,d,d"]
|================
|代数          |値|演算
|関数型        |値、データ|関数
|オブジェクト指向|値、データ、オブジェクト|メソッド
|================

= モノイド

モノイドは、理解するのが簡単、しかし奥が深く、モナドと同じかそれ以上に関数型プログラミングで応用局面もあり実用性が高いという、費用対効果（コスパ）抜群です。

だいたい、モナドを知りたいのなら、まずモノイドを知っておくべきなのは当たり前のことなのですが、ここまでモナド偏重でモノイドについてはあまり語られないのは、<<_モナドを理解するのが難しい理由>>の事情が原因です。

== 単位元

また、小学１年算数を復習すると、

[stem]
++++
1 + 1
++++

みたいな加算を最初に学びます。

子供というか、我々大人でも、脳は、すでに馴染みがある事象の延長・拡張でしか「理解する」というのは無理で、まず最初は、具体的な物質である「数え棒」「おはじき」を渡されて、徐々に数学的な抽象的概念に慣らされていきます。

どういう数学なのかというと、**（正の）自然数全体のなす加法の二項演算**ですよね。一番シンプルなパターンです。

このとき、 `+` は、**（正の）自然数全体** と組（ペア）となる**二項演算**としてしっかりと定義されています。

ところが、授業が進むにつれ様子が変わってきます。


---

https://ja.wikibooks.org/wiki/%E5%B0%8F%E5%AD%A6%E6%A0%A1%E7%AE%97%E6%95%B0/1%E5%AD%A6%E5%B9%B4#%E3%82%BC%E3%83%AD_0[**ゼロ 0**]

_1 から 1 を ひいた かず を ゼロ と いいます。 ゼロ は 0 と かきます。_

_0は、なにも、ない　かず です。_

_だから、 かず に 0 を たしても、 かわりません。_

_たとえば_

_7+0=7_
_「なな たす ゼロ は（わ） なな」です。_

---

[stem]
++++
7 + 0 = 7
++++


ゼロの発明は、数学史の飛躍の一つで、5世紀ごろのインド文明
で数字としてのゼロが発明されたのも数学が生まれてから2000年くらい経過した後ですし、ヨーロッパで広まったのは、中世を経てルネサンスのさらに後のニュートンの時代ですから、人類の数学史を考えると結構最近の発明だと言えます。

それなのに、さらっと小１の子供にゼロの概念をさも当たり前のように伝えるのですから、教育というものの凄まじさを実感するところですね。


**（正の）自然数全体** 

↓

**（ゼロを含む）自然数全体** 

としれっと拡張されてしまいました。

そして、ここで誤魔化されてはならないのが、同じ記号　`+` であっても、ゲームのルールが異なります。

**二項演算**というのは、必ず、演算対象と組（ペア）となってはじめて意味がある定義が成されるはずだったので、

**（正の）自然数全体のなす加法の二項演算**

↓

**（ゼロを含む）自然数全体のなす加法の二項演算**

と、二項演算も同時に更新されてしまいました。




こういう、「だから、 かず に 0 を たしても、 かわりません。」というような、演算で対象が不変になるような数のことを
https://ja.wikipedia.org/wiki/%E5%8D%98%E4%BD%8D%E5%85%83[
単位元]と言います。

---

> 数学、とくに抽象代数学において、単位元（たんいげん, 英: identity element）あるいは中立元（ちゅうりつげん, 英: neutral element）は、二項演算を備えた集合の特別な元で、ほかのどの元もその二項演算による単位元との結合の影響を受けない。

https://ja.wikipedia.org/wiki/%E5%8D%98%E4%BD%8D%E5%85%83[
単位元]

---

[WARNING]
====
「単位元」は、**identity element**から、

- identity
- e

あるいは「中立元」**neutral element**の頭文字**n**に似ている（と筆者は思っている）

- η　（エータ、イータ、イタ）

と表記されることが多いですが、本稿では、とっつきやすさを重視して、

**e**と表記することにします。

ただし、後々まったく同じ数学的対象なのに、後から、単位元のことを、identityと書かれたり、ηと書かれたり、場合によっては `unit` だの　`return`　だの本質ではないところの用語の使い回しで、モナド界隈特有の混乱を極めるので、それは心の準備が必要です。
====




加法の単位元 `e` は `0` ですが、
[stem]
++++
7 + 0 = 7
++++

乗法の単位元 `e` は `1` となります。
[stem]
++++
7 \times 1 = 7
++++

文字列の単位元 `e` は `""`  となります。
[stem]
++++
"Hello" + "" = "Hello"
++++

そして、こういう正の自然数に更に「ゼロの後乗せ」してゼロを含む自然数に拡張する、同時に組（ペア）になっている二項演算子も更新することを、単位元の添加と言います。 

---

_**単位元の添加**_

_マグマ (M, ∗) が与えられたとき、M に M のどの元とも異なる新たな元 1 を付け加えた集合 M1 := M ∪ {1} で_

_任意の a ∈ M1 に対して a * 1 = 1 * a = a_
_と定めて、M の演算 ∗ を M1 上に延長することにより、元 1 を M1 の ∗ に関する単位元とすることができる。この (M1, ∗) を (M, ∗) の 1-添加という。_

_もし、M がもともと ∗ に関する単位元 e を持っていたとしても、e は M1 上ではもはや ∗ に関する単位元ではない。_

https://ja.wikipedia.org/wiki/%E5%8D%98%E4%BD%8D%E5%85%83#%E6%80%A7%E8%B3%AA[単位元#性質]

---


マグマ (M, ∗)に、単位元 e が最初からあるとき、あるいは、正の自然数の二項演算に単位元0 を後から添加してゼロを含む自然数の二項演算とするようなときは、eを加えて、

単位的マグマ

[stem]
++++
(M,e,∗) 
++++

と書くことにしましょう。

組（ペア）から３つ組（トリプル）になったのがポイントです。

具体的な二項演算が定まったときは、

[stem]
++++
(自然数,0,+) 
++++

[stem]
++++
(自然数,1,\times) 
++++

[stem]
++++
(文字列,"",+) 
++++

というようになります。

マグマ(M, ∗) はオブジェクトとメソッドの組として変換できるので、自然数全体:Mのメンバーである特定の値:mで、


[stem]
++++
e + m = m = m + e
++++

[stem]
++++
e.plus(m) = m = m.plus(e) 
++++
 



1 + 2 + 5 + 9
