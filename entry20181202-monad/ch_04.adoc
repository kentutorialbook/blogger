
= モナドとは何か？
ifndef::stem[:stem: latexmath]
ifndef::imagesdir[:imagesdir: ./img/]
ifndef::source-highlighter[:source-highlighter: highlightjs]

ifndef::highlightjs-theme:[:highlightjs-theme: solarized-dark]

++++
<style type="text/css">
p>code {background-color: #aaaaaa};

th,td {
    border: solid 1px;  
}　
td>code {background-color: #aaaaaa};
} 
</style>
++++


> Haskellerにとっては「モナドとはすでに手元にあるもの」であり、手元あるいは、足場となる言語を活用するための学習モティベーションも極めて高い。裏を返すと、Haskellerでないその他大勢のプログラマにとっては以上の事実は逆風となる。 <<ch_01.adoc#_モナドを理解するのが難しい理由>>

さらに裏を返すと、JavaScriptプログラマにとっては、JavaScriptですでにモナドが実装されていて、使えればそれなりにすぐ恩恵がある、とわかれば、テンションもあがるんじゃないでしょうか？

「全部がモナドではないが一部は確実にモナドである」ってどういう意味？っていうのもここでわかります。

全部がモナドではないが一部は確実にモナドである、という事例として、最近のJavaScriptのlink:https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array[Array]があげられます。

> JavaScript の `Array` オブジェクトは、配列を構築するためのグローバルオブジェクトで、配列とは複数の要素の集合を格納管理するリスト構造です。

モナドを紹介するにあたって、`Array` が優れているのは、

- すでに手元にある。すぐに触れる。最新のモダンブラウザやNode.jsならすでに実装済みだ。得体のしれない誰かのモナド実装コードを解読する必要なし。

- 馴染み深い。誰でも知ってる。みんな使える。基本的API。かんたん。

- 見える。コンソール出力したときの値はそのまま値の構造を表している。どうなっているのか一目でわかるので理解も容易。

と三拍子揃っています。


まずは、`Array`　のモナドではない部分を復習して、それからモナドである部分を紹介します。
 

== Array.map

https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/map[Array.map]は、配列の構造(リスト構造)を保ったまま、値にある関数を適用した結果の値を返す、関数です。

`[1, 2, 3, 4, 5]`
に、 + 
値を2倍する関数 + 
`a => a * 2`
を `.map`　すると、 + 
`[2, 4, 6, 8, 10]` +
が返ってきます。


[source,js]
.Array.map.js
----
const array1 = [1, 2, 3, 4, 5];

const array2 =
    array1
        .map(a => a * 2);

console.log(array2);
----

[source,js]
.Console
----
[ 2, 4, 6, 8, 10 ]
----


ここでポイントは、配列の `.map` 前と後で

1. **構造を保ったまま、要素を１:１で転写(map)する**
2. **自分自身＝ `Array` オブジェクトを返してくる**

ことです。


[CAUTION]
.Functor??　**Haskellに寄りすぎ問題**、再度勃発！
====
圏論の用語では、

1. **構造を保ったまま、要素を１:１で転写(map)する**
2. **自分自身＝Arrayオブジェクトを返してくる**


このような性質を備えるオブジェクトのことを、 + 
https://ncatlab.org/nlab/show/endofunctor[Endofunctor](自己関手)と呼びます。

https://ncatlab.org/nlab/show/functor[Functor](関手)の定義は、任意の２つのオブジェクト間の転写(map)をするオブジェクトなので、たとえば、

Array（配列）→Object（オブジェクト）とすると、

`[1, 2, 3, 4, 5]`  + 
↓ + 
`{ first: 1, second: 4, third: 6, fourth: 8, fifth: 10 }`

でも構わないでしょう。

転写(map)先を自分自身であるArrayに限定した特殊なFunctorがEndofunctor(自己関手)となります。

`Array.map` は、自分自身＝ `Array` オブジェクトを返してくる、というのは非常に重要な特性があり、Endofunctor(自己関手)ですが、Haskellコミュニティの因習から、単に、Functorと呼んでしまうことが多いです。

link:https://www.quora.com/Why-is-functor-in-Haskell-defined-like-the-endofunctor-from-category-theory[**Why is functor in Haskell defined like the endofunctor from category theory?**](**なぜ、Haskellのfunctorは、圏論のendofunctorみたいな定義になってるの？**)という極めてまっとうな疑問が出て、"Convenience and history." 便利さと歴史的経緯のせいだ。(中略) Endofunctorという型クラス（type class）名よりも、Functorという名前のほうが" much nicer name"だ。正確じゃないかもしれないが機能している・・・ +
 と、こういったノリです。しかし圏論用語だからとだけ聞かされている初学者にとってはそんなことは知ったことではないわけで、この混乱による質問は定期的に出るようです。

ちなみに、link:http://learnyouahaskell.com/chapters[Learn You a Haskell for Great Good!](無料公開中)（有料日本語訳『すごいHaskellたのしく学ぼう!』）にも、Endofuntorは単にFunctorとだけ書かれているし、「型クラスの命名のノリのことだから些細だ」という問題ではなく、条件に特殊性があるので別の名前がついている別の数学的実体だし、**圏論のFunctorとプログラミングのFunctorでは【意味】が違う**と言ってる人も見てきているので、今からでも遅くないのでちゃんと直したらどうか？と思うわけです。厳密な定義をもつ専門用語全開ぽいので真に受けて聞いていたら、後で「意味が違う」とか「おいちょっと待てよ」と思います。話が通じなくなるので困るのですよね。大事なことなのでここでちゃんと書いておきます。

プログラマ界隈では、ReferenceTransparency(参照透過性)にしろ、もともとの用語の意味が完全に損なわれた不正確な意味で用語を天下り的に教えられて、その不正確な意味を知っていて当然、のようなことが横行しているので要注意。
====


`Array` は、`.map` メソッドで自分自身＝ `Array` オブジェクトを返してくる、Endofunctor(自己関手)の特性の良さにより、メソッドチェーンが可能です。

[source,js]
.メソッドチェーン
----
const array2 =
    array1
        .map(a => a * 2)
        .map(a => a + 1);

console.log(array2);
----

[source,js]
.Console
----
[ 3, 5, 7, 9, 11 ]
----

`Array.map` のメソッドチェーンの連鎖では、`Array` がデータとしてずっと流れていて、エコの統一性が保証されています。

jQueryが便利だ、というのも、モナドどうこう言う以前に、ほとんど、このEndofunctor(自己関手)の特性が大きいです。

さらに、（冒頭で指摘した）IOが純粋関数型で処理できるからモナドがマジカルだという錯覚についても、別にモナドを持ち出すまでもなく、このEndofunctor(自己関手)だけで実現可能です。


[NOTE]
.入れ子構造
====
ただし、構造を保ったまま、といえども、渡す関数を、

`a => a * 2`　+ 
ではなく、 + 
`a => [a * 2]` + 
とすることで


[source,js]
.Console
----
[ [ 2 ], [ 4 ], [ 6 ], [ 8 ], [ 10 ] ]
----

と、各要素の階層を追加することは可能です。
====


== Array.mapと関数型プログラミングの限界

そんなにEndofunctor(自己関手)性質良いなら、モナドの立場は？？モナドの意味は？何が良いの、違うの？となるわけですが、ここの差分をきっちり理解しておくことが重要です。

[source,js]
.メソッドチェーン
----
const array2 =
    array1
        .map(a => a * 2)
        .map(a => a + 1);
----

という一連のシークエンスを再利用可能とするために関数化します。
　
[source,js]
.f関数の定義
----

const f = array =>
    array
        .map(a => a * 2)
        .map(a => a + 1);
----

関数を利用します。


[source,js]
.f関数の利用
----
const array1 = [1, 2, 3, 4, 5];

const array2 = f(array1);　<1>

console.log(array2);
----

<1> `f` 関数の利用

[source,js]
.Console
----
[ 3, 5, 7, 9, 11 ]
----


想定通りの振る舞いで何の問題もありません。

ただし、これまで、`Array` 操作は、`.map` のメソッドチェーンで実現していたのに、`f(array1)`　とSyntaxが変わったことが気になります。


> `Array.map` のメソッドチェーンの連鎖では、`Array` がデータとしてずっと流れていて、エコの統一性が保証されています。

という観点からは。`Array.map` のメソッドチェーンを再利用するための関数 `f` を定義したはいいが、この関数は本当にこの `Array` エコに合致するのか？その保証がほしいです。

ひとつの方法としては、TypeScriptを使って、定義した関数の入力値/出力値の両方に `Array` の型付けをして、TypeScriptトランスパイラにチェックさせる方法があり、これは当然推奨されます。

しかしそれでもなお `Array.map(f)` のメソッドチェーンから飛び出して、`f(array1)`　とSyntaxが変わったエコの不整合さは解消されません。

適用したい関数 `f` が先きてかっこでくくるのが普通の関数適用、メソッドチェーンでは尻尾に `f` つけていますね。ここは結構重要で、メソッドチェーンのエレガントさは、チェーンの後に、また中間でも、追加、挿入自由自在なところにあります。

たとえば、複数回連続して、`f` 適用したい場合、

`f(f(array))` +  
は可読性が悪く「なんとか地獄」の様相なので + 
 `Array.map(f).map(f)` + 

と連鎖で平らに書けたほうが良いですよね？


[TIP]
.ピンと来た人はご名答
====
ES６+Promiseで、「コールバック地獄」から開放される、とか言ってるのも、まさにこの話に対応しています。
====

`f` というのは、そもそもメソッドチェーンの再利用関数だったので、それを再度、メソッドチェーンの中で使うっていうことなので、メソッドチェーンの入れ子構造って可能なの？ってお話をしています。

入れ子構造っていうのは、関数型プログラミングのお家芸というか、自由自在になんでも組み合わせができてなんぼの関数型プログラミングです。今、関数型プログラミングの限界を試しているところです。我々はどこまで行けるのか？



`Array.map` のメソッドチェーンでいけるかどうか？ダメ元で試してみましょうか。

[[challenge]]
[source,js]
.f関数の利用@map ダメ元
----
const array1 = [1, 2, 3, 4, 5];

const array2 =
    array1.map(f);　<1>

console.log(array2);
----

<1> `Array.map(f)` のダメ元チャレンジ

[source,shell]
.Console
----
TypeError: array.map is not a function
----

TypeError つまり型が合いませんでした。

じゃあ、`.map` 元がとりあえず　`Array` にだけなるよう　`[]` でくくって再チャレンジ。

[source,js]
.f関数の利用@map 再チャレンジ
----
const array1 = [1, 2, 3, 4, 5];

const array2 =
    [array1].map(f);　<1>

console.log(array2);
----

<1> `[]` でくくって `[array1]` とする 

[source,shell]
.Console
----
[ [ 3, 5, 7, 9, 11 ] ]
----

いちおう通って `Array` が出てきました！

しかし、残念ながら期待していた

[source,js]
.Console
----
[ 3, 5, 7, 9, 11 ]
----

とはならず、ネストされた二重の `Array` になってしまっています。

もうにっちもさっちもいかないので、ここが `Array.map` の関数型プログラミングでの限界です。

`Array.map` は、自分自身＝ `Array` を返すというEndofunctor(自己関手)の特性があり、メソッドチェーンが出来るのだが、**メソッドチェーンが入れ子構造になると、自身の構造をコントロールできなくなる** のです。

関数型プログラミングにとって、これは結構な大問題だとは思いませんか？

== Array.flat の登場

ネストされた二重の `Array` を 平坦化するには、その機能をもった `Array` メソッドが必要になってきます。

モダンブラウザでは、Chrome69/Firefox62などメジャーどころは、ごく最近、2018年9月に入って立て続けに、
https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/flat[Array.flat]を実装しました。

image::./flat-browser.png[]

Node.jsの最新版でも実装されています。正確なNodeバージョンまでは調査していない。以前までは、これ使いたくても、Polyfillなど使って自前でなんとか拡張する必要があって面倒だったのですが、未だ実験的実装とはいえ歓迎すべきことです。

`Array.flat` メソッドは、その名の通り、ネストされた配列をフラット化します。

[source,js]
.ネストされた配列のフラット化
----
const arr1 = [1, 2, [3, 4]];
arr1.flat(); 
// [1, 2, 3, 4]

const arr2 = [1, 2, [3, 4, [5, 6]]];
arr2.flat();
// [1, 2, 3, 4, [5, 6]]
----

パラメータを指定することで、フラット化するネストの階層を指定できますが、デフォルトでは `1` で、１階層だけフラット化します。それ以上再帰的に追求しません。そして、この１階層だけフラット化するというデフォルトの挙動が本トピックでは適切な振る舞いなので、そのままにしておきましょう。

`unit = a => [a]` を定義しておきます。

[source,js]
.unit(a) = [a]
----
const unit = a => [a];

console.log(
    unit(7)
);
----

[source,js]
.Console
----
[ 7 ]
----

`unit` と `flat` は数学的な対称性(link:https://en.wikipedia.org/wiki/Symmetry_in_mathematics[Symmetry in mathematics])があります。

image::./unitflat1.svg[align="center"]

どちらも、関数の出力値は、`Array` 一択です。

まあ、見たとおり、対称性があって単純で美しい構造だと思うのですが、これは何気に奥深くて、まるで論理クイズみたいな様相を呈します。


この界隈では、「コンテナに入れる」「箱に入れる」「箱から出す」「ラップする」「一枚皮を剥く」「カラに入れる」「カラから出す」はたまた「純粋にする」とか「リフト（アップ）」するとかいろんな言い草がありますが、ここでは単純に「階層」の上下関係で上げる、下げると言いましょう。

ここでの絶対的ルールは以下の2つだけです。

1. `unit` は１階層だけ上げます。

2. `flat` は__ネストされていたならば__１階層だけ下げます。

ルール2で `flat` の仕様として、しれっと条件分岐をしていることに最大限留意してください。

たとえば、

[source,js]
.Array.flat
----
console.log(
    [[7]].flat() <1>
);

console.log(
    [7].flat() <2>
);
----

<1> ネストしてる
<2> ネストしてない

[source,js]
.Console
----
[ 7 ] <1>
[ 7 ] <2>
----
<1> ネストしてたので１階層下げた `Array`
<2> ネストしてなかったので、そのままの `Array`


`Array.flat` は、もし `Array` がネストされてたら、１階層下げて `Array` を返しますが、ネストされていなかったらそのままの `Array` を返します。最後の配列の皮を剥いで、中の生の値 `7` を返すようなことはありません。

つまり、`Array.flat` の返り値は必ず `Array` タイプである、中の値を裸では提供はしません、という基底が保証されています。

`Array.map` はendofunctorで、返り値は必ず `Array` タイプである、という例のメソッドチェーンのエコの部品としてドハマりしますよね？

`Array.flat`　の仕様あるいは、`flat` という共通概念の特性は、 <<challenge>>チャレンジの結果、裸の値に `.map` してしまいタイプエラーが出るような不整合を未然に防止してくれそうです。

`flat` しても、基底はある！しれっと条件分岐でそこはしっかり保証！されたところで、あとは、`unit` と `flat` の上下移動の数学的対称性をもって、どの階層にも自由に移動できます。

image::./unitflat5.svg[align="center"]

誤解しがちなのですが、エコが破綻する裸の値はまずいですが、ネストした構造が別に悪いわけではありません。ネストした `Array` を扱いたいのならば、そのネスト構造を維持しながらコントロールすることもできます。

ここはわかりにくいかもしれないので、次に説明します。いずれにせよ、`flat` が追加されたおかげで、階層の上下の数学的対象性が得られてArray構造を自由にコントロールできるようになります。どうやって自由にコントロールするか？というのは、モナドの使い方の話になってきます。

ああ、紹介が遅れましたが、今話しているこれがモナドです。



== モナド(Monad)

なんのことはない、`Array` で言えば、普通の `Array.map` に `Array.flat` を付け加えたものがモナドになります。

`Array.map` という単独APIだけでは、自身の構造のコントロールはできないendofunctorというだけですが、そこへさらに `Array.flat` が加えることにより、数学的な対称性が得られて、構造をコントロールできるようになるのが、モナド(Monad)です。

念の為に読者へ保証しておきますが、これは、圏論でちゃんと定義づけされているモナド(Monad)のことです。プログラミングのモナドで定義が異なる、という例のトリッキーなアレではありません。

[NOTE]
====
一応裏を取ってみせる必要はあると思うので、とりあえず、英語版Wikipediaの
https://en.wikipedia.org/wiki/Monad_(category_theory)[Monad (category theory)]と、Wikipediaは信頼性がちょっと・・・と言う人も必ずいるので、Web上の圏論の情報では一番豊富で信頼性が高いと思われるnLabを参照します。

どうせnLabと重複するので、英語版Wikipediaは冒頭だけ。

.Monad (category theory)
 
https://en.wikipedia.org/wiki/Monad_(category_theory)

> In category theory, a branch of mathematics, a monad is an endofunctor (a functor mapping a category to itself), together with two natural transformations.  

---

圏論(category theory)では、モナド(monad)とは、endofunctor(カテゴリを自身に転写するfunctor)で、2つの自然変換(natural transformations)を伴っている。

---

endofunctor(カテゴリを自身に転写( `.map` )するfunctor)のことは良いでしょう。それが伴っている、2つの自然変換(natural transformations)というのは、`unit` と `flat` のことです。


 
.monad#definition


https://ncatlab.org/nlab/show/monad#definition

Monads

A monad in a bicategory K is given by

* an object, together with

* an endomorphism t:a→a, and

*  2-cells η:1a→t (the unit of t) and μ:t∘t→t (the multiplication)

---

A monad in a bicategory K というのは、とりあえず置いときましょう。難しいことではまったくないので後でじっくり説明します。

* an object, together with

今のケースで言えば `Array` オブジェクト + 
(以下の表記では `t` と対応している)、 それが以下の性質を伴う 

* an endomorphism `t` :a→a, and

endomorphism  - オブジェクト `t` 自身 を返すメソッド `.map` がある

*  2-cells η:1a→ `t` (the `unit` of `t` ) and μ: `t` ∘ `t` → `t`  (the multiplication)

2つのcells(=morphism)がある、 

stem:[η:] 1a→ `t` + 
一つ階層を上げて `t` を返す `unit` のこと

stem:[μ:] `t` ∘ `t` → `t` + 
`t` が二重にネストしてたら 一つ階層を下げて `t` にして返す `flat` のこと

`flat` は、stem:[TTX \rightarrow TX] などと表記されることが多いので、ああ `flat` のことを言ってるんだなあ、と思っておけばいいです。stem:[TX \rightarrow X] ではない理由は、`flat` の仕様で、例の、stem:[T] （endofunctorオブジェクト）のエコからはみ出てTypeErrorを食らうという裸の値:Xが出ないように基底が決まっている、条件分岐のことを言っているからです。



====

圏論のモナド（monad）の定義をまとめると

1. ベースとして、オブジェクト自身を返す `.map` メソッドを持つendofunctorとしての特性をもつオブジェクトで、さらに以下の２つの関数（メソッド）が付いてる
2. `unit`
3. `flat`

さらにまとめて、

[stem] 
++++ 
(endofunctor, unit, flat)
++++

の３つ組（トリプル）のことをモナドと呼びます。

この辺の組のこと、オブジェクトのことはまだモヤっとしているかもしれないので、bicategoryって何のこと？と合わせて、後でやります。


== リストモナド(List Monad)のつかいかた

モナドの超基本的概念とそれに伴う定義付けは終わったので、あとはそれをどう使うか？です。

`Arrray.map` に `Array.flat` 追加してモナドになった `Array` は、特に **リストモナド(List Monad)**と呼ばれます。

復習しておくと、そもそも、わざわざArrayをモナドにした動機とは、endofunctorだけだと、

> もうにっちもさっちもいかないので、ここが `Array.map` の関数型プログラミングでの限界です。`Array.map` は、自分自身＝ `Array` を返すというEndofunctor(自己関手)の特性があり、メソッドチェーンが出来るのだが、**メソッドチェーンが入れ子構造になると、自身の構造をコントロールできなくなる** のです。

という、限界突破の目的でした。構造をコントロールできるようになりたい。

あと、メソッドチェーンを入れ子構造になっても統一的に扱いたいという話の流れで、仮に構造コントロールできるようになったとして、そのトレードオフとして別のなにかが出来なくなると、同じ局面でendofunctorとモナドの使い分けが必要ということになってしまいます。こうなるとまた収集がつかなくなるのは目に見えているので、トレードオフは受け入れられません。

**モナドは、endofunctorの完全な上位互換であってくれないと使い物にはならない、ということです。上位互換を目指します。**

endofunctorとの互換性を担保するだけならば、理屈は簡単で、 `unit` と `flat` が対称なので、行って来いで、効果を相殺すれば済むことです。その上、`flat` はモナドオブジェクト自身の基底にヒットすると、それ以上階層を下げて裸の値を返すことはない安心保証の性質があるので、それだけでも上位互換となるはずです。


image::./unitflat5.svg[align="center"]


実際にこの理論で上手く行くのか？やってみなきゃわからない。やってみよう。

まず、たたき台となる、普通の `.map` だけのパターン
[source,js]
.Array.map
----
const array1 = [1, 2, 3, 4, 5];

const array2 = array1
    .map(a => a * 2);

console.log(array2);
----

[source,js]
.Console
----
[ 2, 4, 6, 8, 10 ]
----

想定どおりの挙動です。上位互換のモナドでも、まったく同じことを出来なければいけません。

[source,js]
.Array.map　+ flat
----
const unit = a => [a];

const array1 = [1, 2, 3, 4, 5];

const array2 = array1
    .map(a => unit(a * 2)) <1>
    .flat();   <2>

console.log(array2);
----

<1> `a => a * 2` の代わりに、`a => unit(a * 2)` 

<2> `flat` で相殺

[source,js]
.Console
----
[ 2, 4, 6, 8, 10 ]
----

できました。想定した挙動になっています。

さて、重要なポイントとして、`unit` と　`flat` で相殺するには単純に考えると複数のパターンが考えられるはずですが、順番として、なぜ、 `unit` ⇒　`flat` となっているのでしょうか？

理由:

1. 最後に `flat` することで、裸の値でないモナドオブジェクトを返すことを保証できる


2. あらじめ `unit` で構造を自由に指定した上で、`flat` できる


1,2により、相殺して互換性を保つ以上の上位機能が得られます。
1についてはこれ以上説明は不要でしょうが、２については今から説明してきます。

[TIP]
.unit(a) = [a]
====

`unit(a)`

`[a]`

同じ意味ですが、あきらかに可読性と構造の直感的把握がしやすいのは、 `[a]` です。

特にネストした構造になると、

`[ [a] ]` は、 `unit(unit(a))` など煩雑になります。

すでに、`unit` と　`flat` の対称性のことは理解出来たと思うので、、今後特に必要のない限り、`unit(a)` のことは、単純に　`[a]` と表記することにします。

====




メソッドチェーンではどうでしょうか？

まず、たたき台となる、普通の `.map` だけのパターン
[source,js]
.Array.map chain
----
const array1 = [1, 2, 3, 4, 5];

const array2 = array1
    .map(a => a * 2)
    .map(a => a + 1);

console.log(array2);
----

[source,js]
.Console
----
[ 3, 5, 7, 9, 11 ]
----

想定どおりの挙動です。上位互換のモナドでも、まったく同じことを出来なければいけません。

[source,js]
.Array.map　+ flat chain
----
const array1 = [1, 2, 3, 4, 5];

const array2 = array1
    .map(a => [a * 2]).flat()
    .map(a => [a + 1]).flat();

console.log(array2);
----

[source,js]
.Console
----
[ 3, 5, 7, 9, 11 ]
----

問題なく出来ました。

== リストモナドでリスト構造をコントロールする

[source,js]
.要素の数を増やす
----
const array1 = [1, 2, 3, 4, 5];

const array2 = array1
    .map(a => [a, a])　<1>
    .flat(); <2>

console.log(array2);

----

<1> `a => [a, a]` 返り値としてリスト構造を規定する

<2> `[ [ 1, 1 ], [ 2, 2 ], [ 3, 3 ], [ 4, 4 ], [ 5, 5 ] ]` を `flat` 

[source,js]
.Console
----
[ 1, 1, 2, 2, 3, 3, 4, 4, 5, 5 ]
----

[source,js]
.要素の数を増やしたいわけじゃない、`[ [ 1, 1 ], [ 2, 2 ], [ 3, 3 ], [ 4, 4 ], [ 5, 5 ] ]` という構造が欲しいので .mapと同じ結果を寄越せ
----
const array1 = [1, 2, 3, 4, 5];

const array2 = array1
    .map(a => [[a, a]])　<1>
    .flat(); <2>

console.log(array2);
----

<1> `a => [ [a, a] ]` 返り値としてリスト構造を規定する

<2> `[ [ [ 1, 1 ] ],
[ [ 2, 2 ] ],
  [ [ 3, 3 ] ],
  [ [ 4, 4 ] ],
  [ [ 5, 5 ] ] ]` を `flat` 

[source,js]
.Console
----
[ [ 1, 1 ], [ 2, 2 ], [ 3, 3 ], [ 4, 4 ], [ 5, 5 ] ]
----



[source,js]
.要素の数を減らす　奇数のみピックアップ
----
const array1 = [1, 2, 3, 4, 5];

const array2 = array1
    .map(a =>
        a % 2 === 1 <1>
            ? [a]  <2>
            : []   <3>
    ).flat();      <4>

console.log(array2);
----

<1> 配列要素 `a` を `2` で割って余りが `1` なら奇数
<2> 奇数なら、そのままの構造 `[a]` で返す
<3> 奇数でなかったら、構造を削除したいので、`[]` を返す
<4> `[ [1], [], [3], [], [5] ]` を `flat` して　`[ 1, 3, 5 ]`

[source,js]
.Console
----
[ 1, 3, 5 ]
----



== Array.flatMapの登場

`.map(f).flat()` のモナドメソッドはendofunctorの上位互換として機能することが確認出来ました。もうこの確定したパターンでは、逐一尻尾に `.flat()` 着けて回るのはスマートではないしバグの温床にもなりかねません。

そこで、もうこの２つの関数を合成してしまって、ひとつの関数として使い回せたほうが便利ですね。それが関数型プログラミングです。

もちろん合成された関数が `Array` のメソッドとして実装されていないとまた自前でプロトタイプ拡張とかする羽目になって面倒ですが・・・

ということで、あります。

https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap[Array.flatMap]

> flatMap() メソッドは、最初にマッピング関数を使用してそれぞれの要素をマップした後、結果を新しい配列内にフラット化します。これは深さ 1 の flatten が続く map と同じですが、flatMap はしばしば有用であり、2 つのメソッドを 1 つにマージするよりもやや効果的です。

`Array.flatMap` は 最終的に `Array.flat` する `Array.map` という合成関数です。

`Array.flatMap` はもちろんモナドのメソッドです。 

`Array` 以外のモナドで、既存のものにせよ、自前で何か実装するにせよ、endofunctor の `map` に `flat` 合成するというパターンはもう決まりきっているので、多くのモナドの実装では、`flat` は独立した関数として分離しておらず、`flat` は、オブジェクト構造の平坦化　stem:[TTX \rightarrow TX] という機能として、  `flatMap` メソッド(概念として。名前は自由。)のコードに組み入れられて渾然一体となっているケースが多いと思います。




image::./flat-browser.png[]

よく見ると、`Array.flat` の実装状況と同じで、`Array.flat` と　`Array.flatMap`　はふたつセット各ブラウザへ実装されたっぽいことが推察されます。

Array.map+ flat chain　のコードは `Array.flatMap` を使って書き換えられます。

[source,js]
.Array.flatMap chain
----
const array1 = [1, 2, 3, 4, 5];

const array2 = array1
    .flatMap(a => [a * 2])
    .flatMap(a => [a + 1]);

console.log(array2);
----

[source,js]
.Console
----
[ 3, 5, 7, 9, 11 ]
----


では、懸案だったメソッドチェーンのネスト構造でも、この `Array.flatMap` メソッド一つで統一的に書けるようになっているのか？

[source,js]
.Array.flatMap chain
----
const f = array =>
    [array]
        .flatMap(a => [a * 2])
        .flatMap(a => [a + 1]);

const array1 = [1, 2, 3, 4, 5].flatMap(f);

console.log(array1);
----

[source,js]
.Console
----
[ 3, 5, 7, 9, 11 ]
----

余裕です。

さらに、

[source,js]
.Array.flatMap chain2
----
const f = array =>
    [array]
        .flatMap(a => a * 2)   <1>
        .flatMap(a => a + 1);  <2>

const array1 = [1, 2, 3, 4, 5].flatMap(f);

console.log(array1);
----

<1> 非モナドの　`Array.map` のときと同じ関数
<2> 非モナドの　`Array.map` のときと同じ関数

でも同様にうまく動作してしまいます。

[source,js]
.Console
----
[ 3, 5, 7, 9, 11 ]
----

何故か？

そもそも、 `flat` の仕様は、モナドがネストしていない基底のオブジェクトだったら、そのままのオブジェクトを返す、つまり `map` の結果を変化させないというものでした。

上の場合、メソッドチェーンのネスト構造は `flat` して整合性を保ち、なおかつ、ネストしてない部分では、返り値に、`unit` で構造づけしなくても、動作したということです。

これは、基底の階層だけでメソッドチェーンの合成だけ積極的にやりたいというとき、わかってやる分には有用でしょう。有意なネスト構造を意図的に積極的に取り扱う場合はもちろん不整合となるので、留意は必要です。